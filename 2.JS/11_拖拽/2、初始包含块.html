三、初始包含块及系统滚动条的控制
  html和body这两个元素overflow的scroll属性，控制着系统的滚动条
  系统的滚动条有两个，一个是body身上的  一个是document身上的。我们平时看到的那个滚动条
  是document身上的。，如果我们想要控制系统滚动条哪个显示哪个关闭分以下情况：

  1、单独的给body或者html 设置overflow:scroll  滚动条打开的全部都是document的
  2、如果两个元素同时设置overflow属性，body设置的是scroll,html设置是hidden,那么document的滚动条被关闭，body身上的滚动条会打开。
  相反，body身上被关闭，document身上的被打开。
  3、如果两个元素同时设置overflow:hidden；那么系统的两个滚动条全部被关闭；
  4、如果两个都设置overflow:scroll,那么html会打开document身上的，而body会打开自己身上的滚动条；

  由此我们也引出如何禁止系统的滚动条：

	html,body{
    height:100%;    
    //这个属性加上只是为了让设置的overflow:hidden;更有说服力，只有内容超出才会被掩藏或者出现滚动条
		//如果不设置，那么body和html高度将由内容自动撑开，也就是说body当中的内容永远不会溢出。
		overflow:hidden;
  }
  
四、案例：
  1、拖拽的原理（画图）
    点击元素拿到元素的初始位置和鼠标的初始位置
    移动的时候拿到鼠标最后的位置，可以求出鼠标的距离差
    元素最终的位置 = 元素的初始位置 + 鼠标的距离差（移动端很重要，原理就是手指拖拽）
    注意： 两个方向都要去照顾；
  
  2、pc拖拽事件的问题
    事件在谁身上添加？
  
    2.1 刚开始我们把所有事件全部添加在元素身上；
    元素事件是怎么去加，全部平行的去加还是嵌套加，思考这个过程；（嵌套加）
    2.2 move事件在鼠标Up之后不会自动消失；在up事件当中需要将鼠标的move事件和up事件一起取消掉；（解绑） = null
    2.3 接着我们快速的去拖动元素，当鼠标移出元素，再次回去的时候，元素的move事件仍然存在；那么我们就该考虑事件添加是否有问题；
    拖拽当中mousedown的事件确实给元素添加，但是mousemove和mouseup事件要添加在父元素身上，使用事件冒泡去解决元素的移动问题，
    并且鼠标移出元素的时候，我们的事件仍然有效；
    2.4
    当在元素内部我们有文本，文本可以拖拽，所以要取消浏览器的默认行为；
    dom0取消默认行为:事件末尾加return false
    dom2取消默认行为:event.preventDefault()
    取消默认行为之后，发现ie的默认拖拽还是会存在，证明ie的默认行为不包含这个拖拽的，所以我们要进行全局捕获；	
    box.setCapture && box.setCapture(); //当鼠标点击元素之后，把鼠标的后序事件全部捕获到该元素身上。
    box.releaseCapture&& box.releaseCapture(); 鼠标的事件全局捕获，有添加就要有释放，否则后序点击任何地方都相当于在点击box

  3、在基础的拖拽事件上添加边界问题
    当元素在四周的时候，不能超出范围，做出范围界定；
  4、当元素距离四周边界50px时候立即吸附到边界（吸附效果）
  
  5、元素碰撞问题（九宫格）
    计算中间元素到视口上方和左边的距离  getBoundingClientRect() 只能读不能写
    主要是检测什么时候盒子碰撞
    使用图片切换模拟盒子碰撞
  
  6、抽象出拖拽的基础模板
      
晚自习强化练习，完成白天案例
  